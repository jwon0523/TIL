# 추상 클래스(abstract class)

최소 하나의 순수 가상 함수를 가진 클래스를 추상 클래스라고 말하고, 불완전한 클래스이다. 그러므로 추상 클래스의 객체(인스턴스)를 생성할 수 없다.

포인터 변수는 가능하다.

```cpp
Shape shape; // 컴파일 오류
Shape *p = new Shape(); // 컴파일 오류

Shape *p; // 추상 클래스의 포인터 선언으로 오류x
```

## 순수 가상 함수(pure virtual function)

순수 가상 함수는 함수의 코드가 없고 선언만 있는 가상 함수를 뜻하고, 멤버 함수의 원형 뒤에 =0;으로 선언하면 순수 가상 함수가 된다.

순수 가상 함수를 사용하는 이유는 기본 클래스에서 작성된 가상 함수는 실행할 목적보다는 파생 클래스에서 오버라이딩 할 함수를 알려주는 인터페이스 역할을 한다. 그렇기 때문에 기본 클래스의 가상 함수는 거의 실행하지 않기 때문에 이를 순수 가상 함수로 선언하는 것이다.

```cpp
class Shape {
public:
	virtual void draw() = 0; // 순수 가상 함수 선언
};
```

## 추상 클래스의 목적

객체를 생성할 목적으로 만들지 않고, 상속을 위한 기본 클래스로 활용하는 것이 목적이다. 또한 순수 가상 함수를 통해 파생 클래스가 구현할 함수의 원형을 보여주는 인터페이스 역할을 한다.

## 추상 클래스 상속

추상 클래스를 상속받는 파생 클래스는 순수 가상 함수를 그대로 상속받기 때문에 자동으로 추상 클래스가 된다.

```cpp
#include <iostream>
using namespace std;

class Shape { // 추상 클래스
public:
  void paint() {
    draw();
  }
  virtual void draw() = 0; // 순수 가상 함수
};

class Circle : public Shape { // 추상 클래스
public:
  string toString() {
    return "Circle 객체\n";
  }
};
```

```cpp
Circle circle; // 컴파일 오류. 추상 클래스의 객체 생성 불가
Circle *p = new Circle(); // 컴파일 오류. 추상 클래스의 객체 생성 불가
```

## 추상 클래스의 구현

추상 클래스는 순수 가상 함수를 완전하게 구현하지 않고서는 객체 생성이 불가능하다. 

따라서 추상 클래스를 상속 받은 파생 클래스는 추상 클래스의 모든 순수 가상 함수를 오버라이딩하여 구현해야 한다.

![image](https://github.com/jwon0523/TIL/assets/50106190/509667b4-67c8-4512-b592-4790c45ff98b)


## 추상 클래스의 용도

- 파생 클래스에게 특정 멤버 함수의 구현을 강제시킨다.
- 추상 클래스를 이용하면 프로그램의 설계와 구현을 분리할 수 있다.
- 추상 클래스로 기본 방향을 잡아놓고 파생 클래스를 목적에 따라 구현하면 구현 및 관리가 쉬워진다.
- 계층적 상속 관계를 가진 클래스들의 구조를 만들 때 적합하다.

> 출처
명품 C++ Programming - 황기태   
https://gloomystudy.tistory.com/41
>
